#!/usr/bin/python 
# -*- coding: utf-8 -*-
# Ibrahim Khalil <onucsecu@gmail.com> 

# License: 
#    TubeCatcher is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by 
#    the Free Software Foundation, either version 3 of the License, or 
#    (at your option) any later version. 
# 
#    TubeCatcher is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of 
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
#    GNU General Public License for more details. 
# 
#    You should have received a copy of the GNU General Public License 
#    along with TubeCatcher.  If not, see <http://www.gnu.org/licenses/>.

from __future__ import unicode_literals
import gi, sys, gobject
import threading
import youtube_dl
import json
from gi._gi import GObject

gi.require_version('Gtk', '3.0')
from gi.repository import Gtk, GLib
# from pathlib import Path

import os

path = os.path.expanduser('~') + '/Videos/'


class tubecatcher:
    def __init__(self):
        self.gladefile = '/usr/lib/tubecatcher/ui.glade'
        self.builder = Gtk.Builder()
        self.builder.add_from_file(self.gladefile)
        self.builder.connect_signals(self)
        self.window = self.builder.get_object("form")
        self.about=self.builder.get_object("aboutDialogue")
        self.progressbar = self.builder.get_object('progressbar')
        self.progressbar.set_fraction(0.0)
        self.urlentry=self.builder.get_object('urlentry')
        self.textview = self.builder.get_object('status')
        self.ennum = self.builder.get_object('ennum')
        self.stnum = self.builder.get_object('stnum')
        self.playListChkAll = self.builder.get_object('playListChk')
        self.playListChkAll.set_sensitive(False)

        self.output = self.builder.get_object('output')
        self.output.set_text("Output : " + path)
        self.activity_mode = False
        self.value = 0.0
        self.prev = 0.0
        self.nopl = True
        self.AllVid = True
        self.st = 0
        self.en = 0
        self.file_name=''
        self.url_save=''
        self.status = "Processing..."
        self.window.show()
        self.num_of_video=1
        self.num_downloaded_video=0
    def onAbout(self, widget):
        #print('about clicked')
        self.about.show()
    def onAboutDestroy(self,widget):
    	print('dialog closed')
    	self.about.destroy()

    def onQuit(self, widget):
        print('exit')
        sys.exit(0)

    def on_update_status(self):
        self.textbuffer = self.textview.get_buffer()
        self.textbuffer.set_text(self.status)

    def on_progressbar(self):
        self.on_update_status()
        if self.activity_mode:
            self.progressbar.pulse()
        else:
            self.progressbar.set_fraction(self.value/100)
        return True

    def disable_entry(self):
        GLib.idle_add(self.disable_entry)
        if self.AllVid:
            self.stnum.set_sensitive(False)
            self.ennum.set_sensitive(False)
        else:
            self.stnum.set_sensitive(True)
            self.ennum.set_sensitive(True)

    def checkPlaylistUrl(self, widget, data=None):
         if("www.youtube.com/playlist?list=" in widget.get_text()):
            self.nopl = True
            self.AllVid = True
            self.playListChkAll.set_sensitive(True)
         else:
             self.nopl = False
             self.AllVid = False
             self.playListChk.set_sensitive(False)
    def on_toggle_playlist(self, widget, data=None):
        value = widget.get_active()
        self.AllVid = value
        print("ALL Videos: ",self.AllVid , "  Playlist: ",self.nopl)
        thread = threading.Thread(target=self.disable_entry)
        thread.daemon = True
        thread.start()



    def download_proc(self, button, data=None):
        GLib.idle_add(self.on_progressbar)
        # self.urlentry.set_sensitive(False)
        # self.playListChkAll.set_sensitive(False)
        # self.builder.get_object('buttonDownload').set_sensitive(False)

        url = self.urlentry.get_text()
        self.url_save=url
        print(url)
        print(self.nopl)
        if ((self.AllVid==False) and (self.nopl==True)):
            self.st = int(self.stnum.get_text())
            self.en = int(self.ennum.get_text())
        elif((self.AllVid==True)and (self.nopl)==True):
            ydl_opts = {
                'quiet': True,
                'ignoreerrors': True,
            }
            with youtube_dl.YoutubeDL(ydl_opts) as ydl:
                playlist_dict = ydl.extract_info(url, download=False)
            self.num_of_video=len(playlist_dict['entries'])

        def my_hook(d):
            fval=100
            try:
                str = d['_percent_str']
                fval = float(str.replace('%', ''))
                self.value = (fval+(float(self.num_downloaded_video)*100.0))/float(self.num_of_video);
                self.status = d['status'] + ' ' + d['_percent_str'] + ' ' + d['filename']
                self.file_name=d['filename']
                GLib.idle_add(self.on_progressbar)
            except:
                self.status = "closed"
            if d['status'] == 'finished':
                self.status = "Done"
                self.num_downloaded_video = self.num_downloaded_video + 1
                # print('###########################fval ',fval,'num of downloaded vid',self.num_downloaded_video)
                self.value = (fval + (float(self.num_downloaded_video) * 100.0)) / float(self.num_of_video);
                GLib.idle_add(self.on_progressbar)
                print('downloading Finish')
        if self.AllVid:
                ydl_opts = {
                    'format': 'best',
                    'outtmpl': path + '%(title)s' + '.%(ext)s',
                    'noplaylist': False,
                    # 'playliststart': self.st,
                    # 'playlistend': self.en,
                    'ignoreerrors': True,
                    'progress_hooks': [my_hook],
                }
        else:
                ydl_opts = {
                    'format': 'best',
                    'outtmpl': path + '%(title)s' + '.%(ext)s',
                    'noplaylist': False,
                    'playliststart': self.st,
                    'playlistend': self.en,
                    'ignoreerrors': True,
                    'progress_hooks': [my_hook],
                }
        def helloCallBack(url):

            with youtube_dl.YoutubeDL(ydl_opts) as ydl:
                try:
                    ydl.download([url])
                except:
                    print("Error Occured")
                    self.status = "Error Occured"
                    GLib.idle_add(self.on_progressbar)

        thread = threading.Thread(name='triggered', target=helloCallBack, args=[url, ])
        thread.daemon = True
        thread.start()


    def stnum_activate_cb(self, entry, data=None):
        stnum = entry.get_text()
        st = int(stnum)

    def ennum_activate_cb(self, entry, data=None):
        ennum = entry.get_text()
        en = int(ennum)


if __name__ == "__main__":
    main = tubecatcher()
    Gtk.main()


